import { Request, Response } from 'express';
import prisma from '../../lib/prisma';
import { llmService } from '../../services/llmService';

export const sendMailChatMessage = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    if (!userId) return res.status(401).json({ error: 'User not authenticated.' });

    const { message, chatId } = req.body;
    if (!message || typeof message !== 'string') {
      return res.status(400).json({ error: 'No message provided' });
    }

    let chat;
    if (chatId) {
      chat = await prisma.mailChat.findUnique({ where: { id: Number(chatId) } });
      if (!chat) return res.status(404).json({ error: 'Chat not found' });
    } else {
      chat = await prisma.mailChat.create({ data: { userId } });
    }

    // ✅ FIXED: Changed from chatMessage to mailChatMessage
    await prisma.mailChatMessage.create({
      data: { chatId: chat.id, sender: 'user', content: message }
    });

    // Use self-hosted LLM instead of OpenAI
    const systemPrompt = 'You are an expert email writer. Write professional, clear, and effective emails.';
    const userPrompt = `Write an email for the following request:\n\n${message}\n\nReturn only the email body. and at last add this respose in generated by self hosted llm`;
    
    const answer = await llmService.simpleCompletion(
      userPrompt,
      systemPrompt,
      0.8, // temperature - slightly creative
      800  // max tokens - enough for full email
    );
    console.log(answer);
    // ✅ This one was already correct
    await prisma.mailChatMessage.create({
      data: { chatId: chat.id, sender: 'bot', content: answer }
    });

    // Update user limit after successful OpenAI response
    try {
      const token = req.headers.authorization?.split(' ')[1];
      if (token) {
        await fetch(`${process.env.BACKEND_URL || 'http://localhost:5000'}/api/user/update-limit`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ limitType: 'message' })
        });
      }
    } catch (limitError) {
      console.error('Failed to update user limit:', limitError);
      // Don't fail the request if limit update fails
    }

    const messages = await prisma.mailChatMessage.findMany({
      where: { chatId: chat.id },
      orderBy: { createdAt: 'asc' }
    });

    res.json({ chat_id: chat.id, messages });
  } catch (err) {
    console.error('Error in sendMailChatMessage:', err);
    res.status(500).json({ error: 'Failed to process email chat request' });
  }
};

export const getMailChatById = async (req: Request, res: Response) => {
  try {
    const { chat_id } = req.params;
    const userId = (req as any).user?.id;
    const chat = await prisma.mailChat.findUnique({
      where: { id: Number(chat_id) },
      include: { messages: { orderBy: { createdAt: 'asc' } } }
    });
    if (!chat || chat.userId !== userId) {
      return res.status(404).json({ error: 'Chat not found' });
    }
    res.json({ chat_id, messages: chat.messages });
  } catch (err) {
    console.error('Error in getMailChatById:', err);
    res.status(500).json({ error: 'Failed to fetch chat' });
  }
};

export const getUserMailChats = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.id;
    if (!userId) return res.status(401).json({ error: 'User not authenticated.' });
    const chats = await prisma.mailChat.findMany({
      where: { userId },
      orderBy: { updatedAt: 'desc' },
      include: { messages: { orderBy: { createdAt: 'asc' } } }
    });
    res.json({ chats });
  } catch (err) {
    console.error('Error in getUserMailChats:', err);
    res.status(500).json({ error: 'Failed to fetch chats' });
  }
};